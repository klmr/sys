# Command line specification

## Rationale

In an effort to provide a maximally compatible [`argparse`][argparse]
replacement that does not rely on Python, this document aims to specify a
minimal set of supported command line argument options. This should avoid
feature creep and remain quickly implementable — and optionally extensible. On
the other hand, it should provide all or most of the standard POSIX/[GNU
command line syntax][], and offer large compatibility with it (except in cases
where it intentionally diverges).

The API is intentionally not identical to `argparse`’s (pythonic) API. Instead,
an effort is made to provide an opinionated API familiar to R users.

[argparse]: https://cran.r-project.org/web/packages/argparse/index.html
[GNU command line syntax]: http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html

## Supported command line syntax

* Supported are both short and long named arguments and positional arguments,
  all of which may be declared as optional and mandatory, and assigned default
  values
* Short arguments are preceded by `-` and may be grouped into one long string
* Long arguments are preceded by `--`
* Values of short arguments are separated by whitespace or directly adjacent
* Values of long arguments are separated by whitespace, assignment (`=`) or both
* Positional arguments follow named arguments. The special argument `--`
  (without a following name) specifies that all following arguments are
  positional, even if they start with one or more dashes
* Even if undeclared, the special named argument `--help` (`-h`) will print a
  summary of the available command line arguments to stderr and exit
* The same happens when an invalid argument is recognised, but in this case
  additionally with a nonzero exit status

**TODO** Support options with different defaults depending on whether they are
given or not. Example:

Given a specification `opt('s', 'skip', default = default(1, 2))` (or similar),
the following command lines

1. `''`
2. `'--skip'`
3. `'--skip=2'`

Have the semantics

1. `skip == 0`
2. `skip == 1`
3. `skip == 2`.

**TODO** Support arbitrary number of positional arguments:

Given `list(arg('foo', ''), arg_list('bar', ''))`, the command line

    'foo bar baz'

yields

```{r eval=FALSE}
list(foo = 'foo', bar = c('bar', 'baz'))
```

## API

Command line arguments are specified via `opt`:

```{r eval=FALSE}
opt = function (short, long, description, default, validation)
```

Positional argument are specified via `arg`:

```{r eval=FALSE}
arg = function (name, description, default)
```

Used to construct command line specification as follows:

```{r eval=FALSE}
sys$parse_cmdline(sys$opt(…), sys$opt(…), sys$arg(…))
sys$parse_cmdline(opt(…), opt(…), arg(…))
sys$parse_cmdline(opt(…), opt(…), arg(…), c(alternative, command))
```

… in other words, inside a `sys$parse_cmdline` call, `opt` and `arg` are
available without qualification. The last argument of `sys$parse_cmdline` can be
set to a command line invocation to parse (as a vector of arguments as they
would appear on the command line). If none is given, `sys$args` is used.

The command line is given as an argument rather than a string since the parsing
of the command line string into separate arguments is performed by the shell
itself, and the exact algorithm may differ from shell to shell (especially
concerning the escaping of special characters).

## Test cases

```{r echo=FALSE, show='hide'}
modules::import('./cmdline', attach = TRUE)

# Make testable

test_env = environment(parse)
unlockBinding('.sys', test_env)
test_env$.sys = list(exit = function (code, msg) msg)

# TODO: Implement
test = function (cmdline, spec, expected) {
    if (missing(expected))
        expected = 'help'
    args = spec
    args[[length(args) + 1]] = cmdline
    parsed = do.call(parse, args)

    if (is.list(parsed)) {
        if (! lists_equal(parsed, expected)) {
            if (length(parsed) == 0)
                parsed = ''
            warning(sprintf('FAILED test %s: %s',
                            paste(cmdline, collapse = ' '), deparse(parsed)))
        }
    }
    else if (is.character(parsed))
        message(parsed)
}

lists_equal = function (a, b) {
    na = sort(names(a))
    nb = sort(names(b))
    identical(na, nb) && identical(a[na], b[nb])
}
```

### Display the help and exit

```{r}
test('-h', list(arg('x', '')))
test('--help', list(arg('x', '')))
```

### Wrong arguments

```{r}
test(character(0), list(arg('bar', '')))
test('--foo', list(arg('bar', '')))
test('foo', list(opt('b', 'bar', '')))
test('foo', list(opt('b', 'bar', ''), arg('foo', '')))
```

### Collection of short arguments

```{r}
test('-v',
     list(opt('v', 'verbose', 'verbose logging', FALSE)),
     list(verbose = TRUE))
test('-O2',
     list(opt('O', '', 'optimization level', c(optimization = 1))),
     list(optimization = 2))
test(c('-u', 'username'),
     list(opt('u', 'user', 'the username')),
     list(user = 'username'))
# special case: we only allow “-v”, “-vv”, “-vvv” — needs to be validated separately.
test('-vvv', list(opt('v', '', 'level of verbose logging', c(verbose = ''),
                      function (value) value %in% c('', 'v', 'vv'))),
     list(verbose = 'vv'))
# The following doesn’t make sense but hey.
test('-vs', list(opt('v', 'verbose', 'verbose logging', FALSE),
                 opt('s', 'silent', 'silent output', FALSE)),
     list(verbose = TRUE, silent = TRUE))
```

### Equivalently, long options

```{r}
test('--verbose',
     list(opt('v', 'verbose', 'verbose logging', FALSE)),
     list(verbose = TRUE))
test(c('--optim', '2'),
     list(opt('O', 'optim', 'optimization level', c(optimization = 1))),
     list(optimization = 2))
test('--optim=2',
     list(opt('O', 'optim', 'optimization level', c(optimization = 1))),
     list(optimization = 2))
test(c('--verbose', '--silent'), list(opt('v', 'verbose', 'verbose logging', FALSE),
                                      opt('s', 'silent', 'silent output', FALSE)),
     list(verbose = TRUE, silent = TRUE))
```

### Default arguments

```{r}
test('-O2',
     list(opt('v', 'verbose', 'verbose logging', FALSE),
          opt('O', 'optim', 'optimization level', 1),
          arg('tmpdir', 'the path of the temp dir', '~/tmp')),
     list(verbose = FALSE, optim = 2, tmpdir = '~/tmp'))
```
